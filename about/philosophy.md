---
layout: page
title: Engineering Philosophy
---

# Engineering Philosophy

## 1. Systems Thinking

I work comfortably across all layers of the stack:

```text
┌─────────────────────────────────────────┐
│  Application (Go, Python, Vue.js)       │
├─────────────────────────────────────────┤
│  System (Linux, Docker, systemd)        │
├─────────────────────────────────────────┤
│  Kernel (Netfilter, TUN/TAP, POSIX)     │
└─────────────────────────────────────────┘
```

## 2. Architecture First, Code Second

Before writing code, I define:
- **Problem statement** (what are we solving?)
- **Constraints** (what can't we change?)
- **Trade-offs** (what are we willing to sacrifice?)
- **Success metrics** (how do we know it works?)

## 3. Verification Over Assumption

- **Validate inputs** → Universe Validation Stack
- **Monitor outputs** → Prometheus, Grafana, Sentry
- **Document behavior** → Notion specifications, Habr articles

## 4. Teach to Learn

I solidify understanding by teaching:
- **MIPT Go Course** — 11 lectures
- **Habr Articles** — 9 publications
- **Open Source** — 6 public projects

## 5. Iterate Publicly

- Share work early (GitHub, Habr)
- Accept feedback (comments, issues, PRs)
- Improve based on real-world usage
